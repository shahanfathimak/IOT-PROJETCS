#include <WiFi.h>
#include <WebServer.h>
#include <ArduinoJson.h>

// ================= WiFi Credentials =================
const char* ssid = "FLOOD";
const char* password = "12345678";

// ================= Pins =================
#define SENSOR1 34
#define SENSOR2 35
#define SENSOR3 32
#define SENSOR4 33
#define ALERT_PIN 14

// ================= Thresholds =================
const int threshold1 = 2000;
const int threshold2 = 2000;
const int threshold3 = 2000;
const int threshold4 = 2000;

// --- Auto calibration variables ---
int baseThresholds[4] = { threshold1, threshold2, threshold3, threshold4 };
int calibratedThresholds[4] = { threshold1, threshold2, threshold3, threshold4 };
int calibMin[4];
int calibMax[4];
const unsigned long CALIB_TIME = 7000;

// ================= Globals =================
int level1=0, level2=0, level3=0, level4=0;
String status1, status2, status3, status4;
unsigned long buzzerTimer = 0;
bool buzzerActive = false;

WebServer server(80);

// ================= Historical Data =================
#define HISTORY_SIZE 20
int history1[HISTORY_SIZE]={0}, history2[HISTORY_SIZE]={0}, history3[HISTORY_SIZE]={0}, history4[HISTORY_SIZE]={0};
int historyIndex = 0;

// ================= Auto Calibration =================
void calibrateSensors() {
  Serial.println("Starting auto calibration (7 s sampling)...");
  for(int i=0;i<4;i++){ calibMin[i]=4095; calibMax[i]=0; }

  unsigned long start = millis();
  while(millis() - start < CALIB_TIME){
    int vals[4] = { analogRead(SENSOR1), analogRead(SENSOR2),
                    analogRead(SENSOR3), analogRead(SENSOR4) };
    for(int i=0;i<4;i++){
      if(vals[i] < calibMin[i]) calibMin[i] = vals[i];
      if(vals[i] > calibMax[i]) calibMax[i] = vals[i];
    }
    delay(100);
  }

  for(int i=0;i<4;i++){
    if(calibMin[i]>=4095 || calibMax[i]<=0 || calibMax[i]<=calibMin[i]+10){
      calibratedThresholds[i] = baseThresholds[i];
      Serial.printf("S%d: unreliable -> using default %d\n", i+1, baseThresholds[i]);
    } else {
      calibratedThresholds[i] = (calibMin[i] + calibMax[i]) / 2;
      Serial.printf("S%d: min=%d max=%d threshold=%d\n", i+1, calibMin[i], calibMax[i], calibratedThresholds[i]);
    }
  }
  Serial.println("Calibration complete!\n");
}

// ================= Read Sensors =================
void readSensors() {
  level1 = analogRead(SENSOR1);
  level2 = analogRead(SENSOR2);
  level3 = analogRead(SENSOR3);
  level4 = analogRead(SENSOR4);

  status1 = (level1>calibratedThresholds[0])?"âš  FLOOD RISK":"âœ… Safe";
  status2 = (level2>calibratedThresholds[1])?"âš  FLOOD RISK":"âœ… Safe";
  status3 = (level3>calibratedThresholds[2])?"âš  FLOOD RISK":"âœ… Safe";
  status4 = (level4>calibratedThresholds[3])?"âš  FLOOD RISK":"âœ… Safe";

  history1[historyIndex] = level1;
  history2[historyIndex] = level2;
  history3[historyIndex] = level3;
  history4[historyIndex] = level4;
  historyIndex = (historyIndex + 1) % HISTORY_SIZE;

  if ((level1>calibratedThresholds[0] || level2>calibratedThresholds[1] ||
       level3>calibratedThresholds[2] || level4>calibratedThresholds[3]) && !buzzerActive) {
    digitalWrite(ALERT_PIN,HIGH);
    buzzerTimer = millis();
    buzzerActive = true;
  }
}

// ================= JSON API =================
void handleDataJSON(){
  readSensors();
  StaticJsonDocument<512> doc;

  doc["area1"]["level"]=level1; doc["area1"]["status"]=status1;
  doc["area2"]["level"]=level2; doc["area2"]["status"]=status2;
  doc["area3"]["level"]=level3; doc["area3"]["status"]=status3;
  doc["area4"]["level"]=level4; doc["area4"]["status"]=status4;

  JsonArray h1 = doc.createNestedArray("history1");
  JsonArray h2 = doc.createNestedArray("history2");
  JsonArray h3 = doc.createNestedArray("history3");
  JsonArray h4 = doc.createNestedArray("history4");
  for(int i=0;i<HISTORY_SIZE;i++){ 
    h1.add(history1[i]); 
    h2.add(history2[i]); 
    h3.add(history3[i]); 
    h4.add(history4[i]); 
  }

  String json; 
  serializeJson(doc,json);
  server.send(200,"application/json",json);
}

// ================= HTML Dashboard =================
void handleRoot() {
  server.send(200,"text/html",R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flood Monitoring Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body { font-family:'Segoe UI'; background:#e4e9f0; margin:0; }
header { background:#003366; color:white; padding:20px; text-align:center; font-size:2em; }
.container { display:flex; flex-wrap:wrap; justify-content:center; margin:20px; }
.card { background:white; border-radius:15px; padding:20px; width:320px; margin:10px;
        box-shadow:0 10px 25px rgba(0,0,0,0.15); }
.alert { color:red; font-weight:bold; animation:blink 1s infinite; }
.safe { color:green; font-weight:bold; }
@keyframes blink { 50% { opacity:0; } }
.alert-panel { background:#ff4d4d; color:white; padding:15px; text-align:center; 
               font-size:1.3em; font-weight:bold; width:95%; margin:auto; display:none; }
</style>
</head>
<body>
<header>Flood Monitoring Dashboard</header>
<div id="alert-panel" class="alert-panel">ðŸš¨ ALERT: Flood Risk Detected!</div>

<div class="container">
  <div class='card'><h2>Area 1</h2><p id='level1'>Level: --</p><p id='status1'></p><canvas id='chart1'></canvas></div>
  <div class='card'><h2>Area 2</h2><p id='level2'>Level: --</p><p id='status2'></p><canvas id='chart2'></canvas></div>
  <div class='card'><h2>Area 3</h2><p id='level3'>Level: --</p><p id='status3'></p><canvas id='chart3'></canvas></div>
  <div class='card'><h2>Area 4</h2><p id='level4'>Level: --</p><p id='status4'></p><canvas id='chart4'></canvas></div>
</div>

<script>
let chart1, chart2, chart3, chart4;
let h1=[],h2=[],h3=[],h4=[];
function makeChart(ctx,label,data){
  return new Chart(ctx,{
    type:'line',
    data:{labels:Array.from({length:data.length},(_,i)=>i+1),
      datasets:[{label:label,data:data,borderColor:'#003366',
        backgroundColor:'rgba(0,51,102,0.2)',fill:true,tension:0.3}]},
    options:{responsive:true,scales:{y:{beginAtZero:true,max:4095}}}
  });
}

function updateCharts(){
  fetch('/data.json').then(r=>r.json()).then(d=>{
    h1=d.history1; h2=d.history2; h3=d.history3; h4=d.history4;
    chart1.data.datasets[0].data=h1; chart1.update();
    chart2.data.datasets[0].data=h2; chart2.update();
    chart3.data.datasets[0].data=h3; chart3.update();
    chart4.data.datasets[0].data=h4; chart4.update();

    let levels=[d.area1.level,d.area2.level,d.area3.level,d.area4.level];
    let statuses=[d.area1.status,d.area2.status,d.area3.status,d.area4.status];

    for(let i=0;i<4;i++){
      document.getElementById('level'+(i+1)).innerText='Level: '+levels[i];
      document.getElementById('status'+(i+1)).innerText=statuses[i];
      document.getElementById('status'+(i+1)).className=
        statuses[i].includes('âš ')?'alert':'safe';
    }

    document.getElementById('alert-panel').style.display =
      statuses.some(s=>s.includes('âš '))?'block':'none';
  });
}

window.onload=function(){
  chart1=makeChart(document.getElementById('chart1'),'Area 1',h1);
  chart2=makeChart(document.getElementById('chart2'),'Area 2',h2);
  chart3=makeChart(document.getElementById('chart3'),'Area 3',h3);
  chart4=makeChart(document.getElementById('chart4'),'Area 4',h4);
  updateCharts(); setInterval(updateCharts,2000);
};
</script>
</body>
</html>
)rawliteral");
}

// ================= Setup =================
void setup(){
  Serial.begin(115200);
  pinMode(ALERT_PIN,OUTPUT);
  digitalWrite(ALERT_PIN,LOW);

  calibrateSensors();

  WiFi.begin(ssid,password);
  Serial.print("Connecting to WiFi");
  while(WiFi.status()!=WL_CONNECTED){
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected!");
  Serial.println(WiFi.localIP());

  server.on("/",handleRoot);
  server.on("/data.json",handleDataJSON);
  server.begin();
  Serial.println("Server started");
}

// ================= Loop =================
void loop(){
  server.handleClient();
  if(buzzerActive && (millis()-buzzerTimer>2000)){
    digitalWrite(ALERT_PIN,LOW);
    buzzerActive=false;
  }
}
